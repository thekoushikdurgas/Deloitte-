-- PostgreSQL Trigger for zzz_postgresql.json
-- Generated on: 2025-09-03 08:29:15

-- ON INSERT
DO $$ DECLARE V_HOLIDAY_DESCS TXO_VARCHAR_COLL; V_COUNTRY_CODES TXO_VARCHAR_COLL; V_CHK_IS_MULTIVALUE numeric; V_CHK_DISTINCT numeric; BEGIN IF ( OR ) THEN WITH C AS ( SELECT TRIM(SUBSTRING(:NEW.HOLIDAY_NAME, '[^,]+', 1, nan)) COL FROM DUAL CONNECT BY SUBSTRING(:NEW.HOLIDAY_NAME, '[^,]+', 1, nan) IS NOT NULL ) ) SELECT SUBSTRING(C.COL, '[^[]+', 1)        HOLIDAY_DESC, SUBSTRING(C.COL, '[^[]+[^]]', 1, 2) COUNTRY_CD BULK COLLECT INTO V_HOLIDAY_DESCS, V_COUNTRY_CODES FROM C; SELECT COUNT(COUNTRY_CD), COUNT(COLUMN_VALUE) - COUNT(DISTINCT COLUMN_VALUE) INTO V_CHK_IS_MULTIVALUE , V_CHK_DISTINCT FROM TABLE (V_COUNTRY_CODES) LEFT JOIN COUNTRIES ON COUNTRY_CD = COLUMN_VALUE         ; IF V_CHK_IS_MULTIVALUE >= 1 AND V_CHK_IS_MULTIVALUE != V_HOLIDAY_DESCS.COUNT THEN RAISE EXCEPTION ERR_UPD2; END IF; IF V_CHK_DISTINCT > 0 THEN RAISE EXCEPTION ERR_UPD3; END IF; IF V_CHK_IS_MULTIVALUE <= 1 THEN MERGE INTO CFG.CFG_IRTT_HOLIDAYS A USING ( SELECT HOLIDAY_DATE, HOLIDAY_DESC, GRANTED, COUNTRY_CD, HOLIDAY_REMARKS, VALID_IND FROM ( SELECT :NEW.HOLIDAY_DATE    HOLIDAY_DATE, :NEW.HOLIDAY_NAME    HOLIDAY_DESC, :NEW.GRANTED         GRANTED, :NEW.VALID_FOR_CH    CH, :NEW.VALID_FOR_USA   USA, :NEW.VALID_FOR_UK    UK, :NEW.VALID_FOR_FR    FR, :NEW.VALID_FOR_DE    DE, :NEW.VALID_FOR_JP    JP, :NEW.HOLIDAY_REMARKS HOLIDAY_REMARKS FROM DUAL )  UNPIVOT (VALID_IND FOR COUNTRY_CD IN (CH AS 'CH', USA AS 'US', UK AS 'GB', FR AS 'FR', DE AS 'DE', JP AS 'JP')) ) B ON (A.HOLIDAY_DATE = B.HOLIDAY_DATE AND A.COUNTRY_CD = B.COUNTRY_CD) WHEN MATCHED THEN UPDATE SET A.GRANTED = B.GRANTED, A.VALID_IND = B.VALID_IND, A.HOLIDAY_DESC = B.HOLIDAY_DESC, A.HOLIDAY_REMARKS = B.HOLIDAY_REMARKS WHEN NOT MATCHED THEN INSERT(HOLIDAY_DATE, HOLIDAY_DESC, GRANTED, COUNTRY_CD, HOLIDAY_REMARKS, VALID_IND) VALUES(B.HOLIDAY_DATE, B.HOLIDAY_DESC, B.GRANTED, B.COUNTRY_CD, B.HOLIDAY_REMARKS, B.VALID_IND); END IF; IF (:NEW.GRANTED != :OLD.GRANTED) THEN MDMAPPL.MDM_UTIL_IRTT.REGENERATE_EVENT_DATES_FOR_MONTH(P_YEAR => EXTRACT(YEAR FROM :NEW.HOLIDAY_DATE), P_MONTH => EXTRACT(MONTH FROM :NEW.HOLIDAY_DATE), P_START_EVENT_DATE => :NEW.HOLIDAY_DATE); END IF; END IF; END; $$ LANGUAGE plpgsql;

-- ON UPDATE
DO $$ DECLARE V_HOLIDAY_DESCS TXO_VARCHAR_COLL; V_COUNTRY_CODES TXO_VARCHAR_COLL; V_CHK_IS_MULTIVALUE numeric; V_CHK_DISTINCT numeric; BEGIN IF ( OR ) THEN WITH C AS ( SELECT TRIM(SUBSTRING(:NEW.HOLIDAY_NAME, '[^,]+', 1, nan)) COL FROM DUAL CONNECT BY SUBSTRING(:NEW.HOLIDAY_NAME, '[^,]+', 1, nan) IS NOT NULL ) ) SELECT SUBSTRING(C.COL, '[^[]+', 1)  HOLIDAY_DESC, SUBSTRING(C.COL, '[^[]+[^]]', 1, 2) COUNTRY_CD BULK COLLECT INTO V_HOLIDAY_DESCS, V_COUNTRY_CODES FROM C; SELECT COUNT(COUNTRY_CD), COUNT(COLUMN_VALUE) - COUNT(DISTINCT COLUMN_VALUE) INTO V_CHK_IS_MULTIVALUE , V_CHK_DISTINCT FROM TABLE (V_COUNTRY_CODES) LEFT JOIN COUNTRIES ON COUNTRY_CD = COLUMN_VALUE   ; IF V_CHK_IS_MULTIVALUE >= 1 AND V_CHK_IS_MULTIVALUE != V_HOLIDAY_DESCS.COUNT THEN RAISE EXCEPTION ERR_UPD2; END IF; IF V_CHK_DISTINCT > 0 THEN RAISE EXCEPTION ERR_UPD3; END IF; IF V_CHK_IS_MULTIVALUE <= 1 THEN MERGE INTO CFG.CFG_IRTT_HOLIDAYS A USING ( SELECT HOLIDAY_DATE, HOLIDAY_DESC, GRANTED, COUNTRY_CD, HOLIDAY_REMARKS, VALID_IND FROM ( SELECT :NEW.HOLIDAY_DATE HOLIDAY_DATE, :NEW.HOLIDAY_NAME HOLIDAY_DESC, :NEW.GRANTED   GRANTED, :NEW.VALID_FOR_CH CH, :NEW.VALID_FOR_USA   USA, :NEW.VALID_FOR_UK UK, :NEW.VALID_FOR_FR FR, :NEW.VALID_FOR_DE DE, :NEW.VALID_FOR_JP JP, :NEW.HOLIDAY_REMARKS HOLIDAY_REMARKS FROM DUAL )  UNPIVOT (VALID_IND FOR COUNTRY_CD IN (CH AS 'CH', USA AS 'US', UK AS 'GB', FR AS 'FR', DE AS 'DE', JP AS 'JP')) ) B ON (A.HOLIDAY_DATE = B.HOLIDAY_DATE AND A.COUNTRY_CD = B.COUNTRY_CD) WHEN MATCHED THEN UPDATE SET A.GRANTED = B.GRANTED, A.VALID_IND = B.VALID_IND, A.HOLIDAY_DESC = B.HOLIDAY_DESC, A.HOLIDAY_REMARKS = B.HOLIDAY_REMARKS WHEN NOT MATCHED THEN INSERT(HOLIDAY_DATE, HOLIDAY_DESC, GRANTED, COUNTRY_CD, HOLIDAY_REMARKS, VALID_IND) VALUES(B.HOLIDAY_DATE, B.HOLIDAY_DESC, B.GRANTED, B.COUNTRY_CD, B.HOLIDAY_REMARKS, B.VALID_IND); END IF; IF (:NEW.GRANTED != :OLD.GRANTED) THEN MDMAPPL.MDM_UTIL_IRTT.REGENERATE_EVENT_DATES_FOR_MONTH(P_YEAR => EXTRACT(YEAR FROM :NEW.HOLIDAY_DATE), P_MONTH => EXTRACT(MONTH FROM :NEW.HOLIDAY_DATE), P_START_EVENT_DATE => :NEW.HOLIDAY_DATE); END IF; END IF; END; $$ LANGUAGE plpgsql;

-- ON DELETE
DO $$ DECLARE V_HOLIDAY_DESCS TXO_VARCHAR_COLL; V_COUNTRY_CODES TXO_VARCHAR_COLL; V_CHK_IS_MULTIVALUE numeric; V_CHK_DISTINCT numeric; BEGIN IF TRUE THEN IF :OLD.HOLIDAY_DATE IS NULL THEN RAISE EXCEPTION ERR_DEL; END IF; DELETE FROM CFG.CFG_IRTT_HOLIDAYS A WHERE A.HOLIDAY_DATE = :OLD.HOLIDAY_DATE; END IF; END; $$ LANGUAGE plpgsql;
